#include <cstdint>
#include <vector>
#include <cstring>
#include <iostream>

// S盒
static const uint8_t S0[256] = {
    0x3E,0x72,0x5B,0x47,0xCA,0xE0,0x00,0x33,0x04,0xD1,0x54,0x98,0x09,0xB9,0x6D,0xCB,
    0x7B,0x1B,0xF9,0x32,0xAF,0x9D,0x6A,0xA5,0xB8,0x2D,0xFC,0x1D,0x08,0x53,0x03,0x90,
    0x4D,0x4E,0x84,0x99,0xE4,0xCE,0xD9,0x91,0xDD,0xB6,0x85,0x48,0x8B,0x29,0x6E,0xAC,
    0xCD,0xC1,0xF8,0x1E,0x73,0x43,0x69,0xC6,0xB5,0xBD,0xFD,0x39,0x63,0x20,0xD4,0x38,
    0x76,0x7D,0xB2,0xA7,0xCF,0xED,0x57,0xC5,0xF3,0x2C,0xBB,0x14,0x21,0x06,0x55,0x9B,
    0xE3,0xEF,0x5E,0x31,0x4F,0x7F,0x5A,0xA4,0x0D,0x82,0x51,0x49,0x5F,0xBA,0x58,0x1C,
    0x4A,0x16,0xD5,0x17,0xA8,0x92,0x24,0x1F,0x8C,0xFF,0xD8,0xAE,0x2E,0x01,0xD3,0xAD,
    0x3B,0x4B,0xDA,0x46,0xEB,0xC9,0xDE,0x9A,0x8F,0x87,0xD7,0x3A,0x80,0x6F,0x2F,0xC8,
    0xB1,0xB4,0x37,0xF7,0x0A,0x22,0x13,0x28,0x7C,0xCC,0x3C,0x89,0xC7,0xC3,0x96,0x56,
    0x07,0xBF,0x7E,0xF0,0x0B,0x2B,0x97,0x52,0x35,0x41,0x79,0x61,0xA6,0x4C,0x10,0xFE,
    0xBC,0x26,0x95,0x88,0x8A,0xB0,0xA3,0xFB,0xC0,0x18,0x94,0xF2,0xE1,0xE5,0xE9,0x5D,
    0xD0,0xDC,0x11,0x66,0x64,0x5C,0xEC,0x59,0x42,0x75,0x12,0xF5,0x74,0x9C,0xAA,0x23,
    0x0E,0x86,0xAB,0xBE,0x2A,0x02,0xE7,0x67,0xE6,0x44,0xA2,0x6C,0xC2,0x93,0x9F,0xF1,
    0xF6,0xFA,0x36,0xD2,0x50,0x68,0x9E,0x62,0x71,0x15,0x3D,0xD6,0x40,0xC4,0xE2,0x0F,
    0x8E,0x83,0x77,0x6B,0x25,0x05,0x3F,0x0C,0x30,0xEA,0x70,0xB7,0xA1,0xE8,0xA9,0x65,
    0x8D,0x27,0x1A,0xDB,0x81,0xB3,0xA0,0xF4,0x45,0x7A,0x19,0xDF,0xEE,0x78,0x34,0x60
};

static const uint8_t S1[256] = {
    0x55,0xC2,0x63,0x71,0x3B,0xC8,0x47,0x86,0x9F,0x3C,0xDA,0x5B,0x29,0xAA,0xFD,0x77,
    0x8C,0xC5,0x94,0x0C,0xA6,0x1A,0x13,0x00,0xE3,0xA8,0x16,0x72,0x40,0xF9,0xF8,0x42,
    0x44,0x26,0x68,0x96,0x81,0xD9,0x45,0x3E,0x10,0x76,0xC6,0xA7,0x8B,0x39,0x43,0xE1,
    0x3A,0xB5,0x56,0x2A,0xC0,0x6D,0xB3,0x05,0x22,0x66,0xBF,0xDC,0x0B,0xFA,0x62,0x48,
    0xDD,0x20,0x11,0x06,0x36,0xC9,0xC1,0xCF,0xF6,0x27,0x52,0xBB,0x69,0xF5,0xD4,0x87,
    0x7F,0x84,0x4C,0xD2,0x9C,0x57,0xA4,0xBC,0x4F,0x9A,0xDF,0xFE,0xD6,0x8D,0x7A,0xEB,
    0x2B,0x53,0xD8,0x5C,0xA1,0x14,0x17,0xFB,0x23,0xD5,0x7D,0x30,0x67,0x73,0x08,0x09,
    0xEE,0xB7,0x70,0x3F,0x61,0xB2,0x19,0x8E,0x4E,0xE5,0x4B,0x93,0x8F,0x5D,0xDB,0xA9,
    0xAD,0xF1,0xAE,0x2E,0xCB,0x0D,0xFC,0xF4,0x2D,0x46,0x6E,0x1D,0x97,0xE8,0xD1,0xE9,
    0x4D,0x37,0xA5,0x75,0x5E,0x83,0x9E,0xAB,0x82,0x9D,0xB9,0x1C,0xE0,0xCD,0x49,0x89,
    0x01,0xB6,0xBD,0x58,0x24,0xA2,0x5F,0x38,0x78,0x99,0x15,0x90,0x50,0xB8,0x95,0xE4,
    0xD0,0x91,0xC7,0xCE,0xED,0x0F,0xB4,0x6F,0xA0,0xCC,0xF0,0x02,0x4A,0x79,0xC3,0xDE,
    0xA3,0xEF,0xEA,0x51,0xE6,0x6B,0x18,0xEC,0x1B,0x2C,0x80,0xF7,0x74,0xE7,0xFF,0x21,
    0x5A,0x6A,0x54,0x1E,0x41,0x31,0x92,0x35,0xC4,0x33,0x07,0x0A,0xBA,0x7E,0x0E,0x34,
    0x88,0xB1,0x98,0x7C,0xF3,0x3D,0x60,0x6C,0x7B,0xCA,0xD3,0x1F,0x32,0x65,0x04,0x28,
    0x64,0xBE,0x85,0x9B,0x2F,0x59,0x8A,0xD7,0xB0,0x25,0xAC,0xAF,0x12,0x03,0xE2,0xF2
};

static const uint16_t D[16] = {
    0x44D7,0x26BC,0x626B,0x135E,0x5789,0x35E2,0x7135,0x09AF,
    0x4D78,0x2F13,0x6BC4,0x1AF1,0x5E26,0x3C4D,0x789A,0x47AC
};

#define LFSR_SIZE 16

// 31位加法
inline uint32_t addition_uint31(uint32_t a, uint32_t b) {
    uint32_t c = a + b;
    return (c & 0x7FFFFFFF) + (c >> 31);
}

// 31位循环左移
inline uint32_t rotl_uint31(uint32_t a, int shift) {
    return ((a << shift) | (a >> (31 - shift))) & 0x7FFFFFFF;
}

// 32位循环左移
inline uint32_t rotl_uint32(uint32_t a, int shift) {
    return ((a << shift) | (a >> (32 - shift))) & 0xFFFFFFFF;
}

// 线性变换
inline uint32_t L1(uint32_t x) {
    return x ^ rotl_uint32(x, 2) ^ rotl_uint32(x, 10) ^ rotl_uint32(x, 18) ^ rotl_uint32(x, 24);
}
inline uint32_t L2(uint32_t x) {
    return x ^ rotl_uint32(x, 8) ^ rotl_uint32(x, 14) ^ rotl_uint32(x, 22) ^ rotl_uint32(x, 30);
}

// 合成32位
inline uint32_t make_uint32(uint8_t a, uint8_t b, uint8_t c, uint8_t d) {
    return ((uint32_t)a << 24) | ((uint32_t)b << 16) | ((uint32_t)c << 8) | d;
}

// 合成31位
inline uint32_t make_uint31(uint8_t a, uint16_t b, uint8_t c) {
    return (((uint32_t)a << 23) & 0x7FFFFFFF) | (((uint32_t)b << 8) & 0x7FFFFF00) | (c & 0xFF);
}

// ZUC上下文
struct ZUC_CTX {
    uint32_t lfsr[LFSR_SIZE];
    uint32_t r1, r2;
    uint32_t x[4];
};

// 比特重组
void bit_reorganization(ZUC_CTX &ctx) {
    ctx.x[0] = ((ctx.lfsr[15] & 0x7FFF8000) << 1) | (ctx.lfsr[14] & 0xFFFF);
    ctx.x[1] = ((ctx.lfsr[11] & 0xFFFF) << 16) | (ctx.lfsr[9] >> 15);
    ctx.x[2] = ((ctx.lfsr[7] & 0xFFFF) << 16) | (ctx.lfsr[5] >> 15);
    ctx.x[3] = ((ctx.lfsr[2] & 0xFFFF) << 16) | (ctx.lfsr[0] >> 15);
}

// LFSR下一个状态
uint32_t lfsr_next(const ZUC_CTX &ctx) {
    uint32_t f = ctx.lfsr[0];
    f = addition_uint31(f, rotl_uint31(ctx.lfsr[0], 8));
    f = addition_uint31(f, rotl_uint31(ctx.lfsr[4], 20));
    f = addition_uint31(f, rotl_uint31(ctx.lfsr[10], 21));
    f = addition_uint31(f, rotl_uint31(ctx.lfsr[13], 17));
    f = addition_uint31(f, rotl_uint31(ctx.lfsr[15], 15));
    return f;
}

// LFSR移位
void lfsr_shift(ZUC_CTX &ctx) {
    uint32_t f = lfsr_next(ctx);
    for (int i = 0; i < LFSR_SIZE - 1; ++i)
        ctx.lfsr[i] = ctx.lfsr[i + 1];
    ctx.lfsr[LFSR_SIZE - 1] = f;
}

// LFSR初始化
void lfsr_init(ZUC_CTX &ctx, uint32_t u) {
    uint32_t f = addition_uint31(lfsr_next(ctx), u);
    for (int i = 0; i < LFSR_SIZE - 1; ++i)
        ctx.lfsr[i] = ctx.lfsr[i + 1];
    ctx.lfsr[LFSR_SIZE - 1] = f;
}

// S盒变换
inline uint32_t Sbox(uint32_t w) {
    return ((uint32_t)S0[(w >> 24) & 0xFF] << 24) |
           ((uint32_t)S1[(w >> 16) & 0xFF] << 16) |
           ((uint32_t)S0[(w >> 8) & 0xFF] << 8) |
           ((uint32_t)S1[w & 0xFF]);
}

// F函数
uint32_t F(ZUC_CTX &ctx) {
    uint32_t W = ((ctx.x[0] ^ ctx.r1) + ctx.r2) & 0xFFFFFFFF;
    uint32_t W1 = (ctx.r1 + ctx.x[1]) & 0xFFFFFFFF;
    uint32_t W2 = ctx.r2 ^ ctx.x[2];
    uint32_t u = L1(((W1 & 0x0000FFFF) << 16) | (W2 >> 16));
    uint32_t v = L2(((W2 & 0x0000FFFF) << 16) | (W1 >> 16));
    ctx.r1 = Sbox(u);
    ctx.r2 = Sbox(v);
    return W;
}

// 密钥装载与初始化
void zuc_init(ZUC_CTX &ctx, const uint8_t key[16], const uint8_t iv[16]) {
    for (int i = 0; i < 16; ++i)
        ctx.lfsr[i] = make_uint31(key[i], D[i], iv[i]);
    ctx.r1 = ctx.r2 = 0;
    for (int i = 0; i < 32; ++i) {
        bit_reorganization(ctx);
        uint32_t w = F(ctx);
        lfsr_init(ctx, w >> 1);
    }
}

// 生成密钥流
void zuc_generate_keystream(ZUC_CTX &ctx, uint32_t *keystream, int n) {
    bit_reorganization(ctx);
    F(ctx); // 丢弃第一次输出
    for (int i = 0; i < n; ++i) {
        lfsr_shift(ctx);
        bit_reorganization(ctx);
        keystream[i] = F(ctx) ^ ctx.x[3];
    }
    lfsr_shift(ctx);
}

// 加解密
void zuc_encrypt(ZUC_CTX &ctx, const uint8_t *input, uint8_t *output, int len) {
    std::vector<uint32_t> keystream((len + 3) / 4);
    zuc_generate_keystream(ctx, keystream.data(), keystream.size());
    for (int i = 0; i < len; ++i) {
        output[i] = input[i] ^ ((keystream[i / 4] >> (8 * (3 - (i % 4)))) & 0xFF);
    }
}

// 示例用法
int main() {
    uint8_t key[16] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                       0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    uint8_t iv[16] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    ZUC_CTX ctx;
    zuc_init(ctx, key, iv);
    const char *msg = "i love u";
    int len = strlen(msg);
    std::vector<uint8_t> enc(len), dec(len);

    // 输出密钥流
    std::vector<uint32_t> keystream((len + 3) / 4);
    zuc_generate_keystream(ctx, keystream.data(), keystream.size());
    std::cout << "生成的密钥流: ";
    for (auto v : keystream) printf("%08x ", v);
    std::cout << std::endl;

    // 重新初始化ctx用于加密
    zuc_init(ctx, key, iv);
    zuc_encrypt(ctx, (const uint8_t*)msg, enc.data(), len);
    std::cout << "加密得到的字流: ";
    for (auto v : enc) printf("%02x ", v);
    std::cout << std::endl;

    // 解密
    ZUC_CTX ctx2;
    zuc_init(ctx2, key, iv);
    zuc_encrypt(ctx2, enc.data(), dec.data(), len);
    std::cout << "解密得到的字流: ";
    for (auto v : dec) printf("%02x ", v);
    std::cout << std::endl;
    std::cout << "明文: " << std::string(dec.begin(), dec.end()) << std::endl;
    return 0;
}
